// Autogenerated code. Do not modify.
package net.paulgray.lti.message;

import java.util.Objects;
import java.util.Optional;
import java.util.function.UnaryOperator;
import javax.annotation.Generated;
import javax.annotation.Nullable;

/**
 * Auto-generated superclass of {@link Context.Builder}, derived from the API of {@link Context}.
 */
@Generated("org.inferred.freebuilder.processor.CodeGenerator")
abstract class Context_Builder {

  /** Creates a new builder using {@code value} as a template. */
  public static Context.Builder from(Context value) {
    return Context.builder().mergeFrom(value);
  }

  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private String id = null;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private String label = null;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private String title = null;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private String type = null;

  /**
   * Sets the value to be returned by {@link Context#id()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code id} is null
   */
  public Context.Builder id(String id) {
    this.id = Objects.requireNonNull(id);
    return (Context.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Context#id()}.
   *
   * @return this {@code Builder} object
   */
  public Context.Builder id(Optional<? extends String> id) {
    if (id.isPresent()) {
      return id(id.get());
    } else {
      return clearId();
    }
  }

  /**
   * Sets the value to be returned by {@link Context#id()}.
   *
   * @return this {@code Builder} object
   */
  public Context.Builder nullableId(@Nullable String id) {
    if (id != null) {
      return id(id);
    } else {
      return clearId();
    }
  }

  /**
   * If the value to be returned by {@link Context#id()} is present, replaces it by applying {@code
   * mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Context.Builder mapId(UnaryOperator<String> mapper) {
    return id(id().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Context#id()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Context.Builder clearId() {
    id = null;
    return (Context.Builder) this;
  }

  /** Returns the value that will be returned by {@link Context#id()}. */
  public Optional<String> id() {
    return Optional.ofNullable(id);
  }

  /**
   * Sets the value to be returned by {@link Context#label()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code label} is null
   */
  public Context.Builder label(String label) {
    this.label = Objects.requireNonNull(label);
    return (Context.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Context#label()}.
   *
   * @return this {@code Builder} object
   */
  public Context.Builder label(Optional<? extends String> label) {
    if (label.isPresent()) {
      return label(label.get());
    } else {
      return clearLabel();
    }
  }

  /**
   * Sets the value to be returned by {@link Context#label()}.
   *
   * @return this {@code Builder} object
   */
  public Context.Builder nullableLabel(@Nullable String label) {
    if (label != null) {
      return label(label);
    } else {
      return clearLabel();
    }
  }

  /**
   * If the value to be returned by {@link Context#label()} is present, replaces it by applying
   * {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Context.Builder mapLabel(UnaryOperator<String> mapper) {
    return label(label().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Context#label()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Context.Builder clearLabel() {
    label = null;
    return (Context.Builder) this;
  }

  /** Returns the value that will be returned by {@link Context#label()}. */
  public Optional<String> label() {
    return Optional.ofNullable(label);
  }

  /**
   * Sets the value to be returned by {@link Context#title()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code title} is null
   */
  public Context.Builder title(String title) {
    this.title = Objects.requireNonNull(title);
    return (Context.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Context#title()}.
   *
   * @return this {@code Builder} object
   */
  public Context.Builder title(Optional<? extends String> title) {
    if (title.isPresent()) {
      return title(title.get());
    } else {
      return clearTitle();
    }
  }

  /**
   * Sets the value to be returned by {@link Context#title()}.
   *
   * @return this {@code Builder} object
   */
  public Context.Builder nullableTitle(@Nullable String title) {
    if (title != null) {
      return title(title);
    } else {
      return clearTitle();
    }
  }

  /**
   * If the value to be returned by {@link Context#title()} is present, replaces it by applying
   * {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Context.Builder mapTitle(UnaryOperator<String> mapper) {
    return title(title().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Context#title()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Context.Builder clearTitle() {
    title = null;
    return (Context.Builder) this;
  }

  /** Returns the value that will be returned by {@link Context#title()}. */
  public Optional<String> title() {
    return Optional.ofNullable(title);
  }

  /**
   * Sets the value to be returned by {@link Context#type()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code type} is null
   */
  public Context.Builder type(String type) {
    this.type = Objects.requireNonNull(type);
    return (Context.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Context#type()}.
   *
   * @return this {@code Builder} object
   */
  public Context.Builder type(Optional<? extends String> type) {
    if (type.isPresent()) {
      return type(type.get());
    } else {
      return clearType();
    }
  }

  /**
   * Sets the value to be returned by {@link Context#type()}.
   *
   * @return this {@code Builder} object
   */
  public Context.Builder nullableType(@Nullable String type) {
    if (type != null) {
      return type(type);
    } else {
      return clearType();
    }
  }

  /**
   * If the value to be returned by {@link Context#type()} is present, replaces it by applying
   * {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Context.Builder mapType(UnaryOperator<String> mapper) {
    return type(type().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Context#type()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Context.Builder clearType() {
    type = null;
    return (Context.Builder) this;
  }

  /** Returns the value that will be returned by {@link Context#type()}. */
  public Optional<String> type() {
    return Optional.ofNullable(type);
  }

  /** Sets all property values using the given {@code Context} as a template. */
  public Context.Builder mergeFrom(Context value) {
    value.id().ifPresent(this::id);
    value.label().ifPresent(this::label);
    value.title().ifPresent(this::title);
    value.type().ifPresent(this::type);
    return (Context.Builder) this;
  }

  /**
   * Copies values from the given {@code Builder}. Does not affect any properties not set on the
   * input.
   */
  public Context.Builder mergeFrom(Context.Builder template) {
    template.id().ifPresent(this::id);
    template.label().ifPresent(this::label);
    template.title().ifPresent(this::title);
    template.type().ifPresent(this::type);
    return (Context.Builder) this;
  }

  /** Resets the state of this builder. */
  public Context.Builder clear() {
    Context_Builder _defaults = Context.builder();
    id = _defaults.id;
    label = _defaults.label;
    title = _defaults.title;
    type = _defaults.type;
    return (Context.Builder) this;
  }

  /** Returns a newly-created {@link Context} based on the contents of the {@code Builder}. */
  public Context build() {
    return new Context_Builder.Value(this);
  }

  /**
   * Returns a newly-created partial {@link Context} for use in unit tests. State checking will not
   * be performed.
   *
   * <p>Partials should only ever be used in tests. They permit writing robust test cases that won't
   * fail if this type gains more application-level constraints (e.g. new required fields) in
   * future. If you require partially complete values in production code, consider using a Builder.
   */
  public Context buildPartial() {
    return new Context_Builder.Partial(this);
  }

  private static final class Value implements Context {
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String id;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String label;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String title;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String type;

    private Value(Context_Builder builder) {
      this.id = builder.id;
      this.label = builder.label;
      this.title = builder.title;
      this.type = builder.type;
    }

    @Override
    public Optional<String> id() {
      return Optional.ofNullable(id);
    }

    @Override
    public Optional<String> label() {
      return Optional.ofNullable(label);
    }

    @Override
    public Optional<String> title() {
      return Optional.ofNullable(title);
    }

    @Override
    public Optional<String> type() {
      return Optional.ofNullable(type);
    }

    @Override
    public Context.Builder toBuilder() {
      return Context.builder().mergeFrom(this);
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Context_Builder.Value)) {
        return false;
      }
      Context_Builder.Value other = (Context_Builder.Value) obj;
      return Objects.equals(id, other.id)
          && Objects.equals(label, other.label)
          && Objects.equals(title, other.title)
          && Objects.equals(type, other.type);
    }

    @Override
    public int hashCode() {
      return Objects.hash(id, label, title, type);
    }

    @Override
    public String toString() {
      StringBuilder result = new StringBuilder("Context{");
      String separator = "";
      if (id != null) {
        result.append("id=").append(id);
        separator = ", ";
      }
      if (label != null) {
        result.append(separator);
        result.append("label=").append(label);
        separator = ", ";
      }
      if (title != null) {
        result.append(separator);
        result.append("title=").append(title);
        separator = ", ";
      }
      if (type != null) {
        result.append(separator);
        result.append("type=").append(type);
      }
      result.append("}");
      return result.toString();
    }
  }

  private static final class Partial implements Context {
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String id;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String label;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String title;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String type;

    Partial(Context_Builder builder) {
      this.id = builder.id;
      this.label = builder.label;
      this.title = builder.title;
      this.type = builder.type;
    }

    @Override
    public Optional<String> id() {
      return Optional.ofNullable(id);
    }

    @Override
    public Optional<String> label() {
      return Optional.ofNullable(label);
    }

    @Override
    public Optional<String> title() {
      return Optional.ofNullable(title);
    }

    @Override
    public Optional<String> type() {
      return Optional.ofNullable(type);
    }

    private static class PartialBuilder extends Context.Builder {
      @Override
      public Context build() {
        return buildPartial();
      }
    }

    @Override
    public Context.Builder toBuilder() {
      Context.Builder builder = new PartialBuilder();
      builder.nullableId(id);
      builder.nullableLabel(label);
      builder.nullableTitle(title);
      builder.nullableType(type);
      return builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Context_Builder.Partial)) {
        return false;
      }
      Context_Builder.Partial other = (Context_Builder.Partial) obj;
      return Objects.equals(id, other.id)
          && Objects.equals(label, other.label)
          && Objects.equals(title, other.title)
          && Objects.equals(type, other.type);
    }

    @Override
    public int hashCode() {
      return Objects.hash(id, label, title, type);
    }

    @Override
    public String toString() {
      StringBuilder result = new StringBuilder("partial Context{");
      String separator = "";
      if (id != null) {
        result.append("id=").append(id);
        separator = ", ";
      }
      if (label != null) {
        result.append(separator);
        result.append("label=").append(label);
        separator = ", ";
      }
      if (title != null) {
        result.append(separator);
        result.append("title=").append(title);
        separator = ", ";
      }
      if (type != null) {
        result.append(separator);
        result.append("type=").append(type);
      }
      result.append("}");
      return result.toString();
    }
  }
}
